#
# USB Gadget support on a system involves
#    (a) a peripheral controller, and
#    (b) the gadget driver using it.
#
# NOTE:  Gadget support ** DOES NOT ** depend on host-side CONFIG_USB !!
#
#  - Host systems (like PCs) need CONFIG_USB (with "A" jacks).
#  - Peripherals (like PDAs) need CONFIG_USB_GADGET (with "B" jacks).
#  - Some systems have both kinds of controllers.
#
# With help from a special transceiver and a "Mini-AB" jack, systems with
# both kinds of controller can also support "USB On-the-Go" (CONFIG_USB_OTG).
#

menuconfig USB_GADGET
	tristate "USB Gadget Support"
	help
	   USB is a master/slave protocol, organized with one master
	   host (such as a PC) controlling up to 127 peripheral devices.
	   The USB hardware is asymmetric, which makes it easier to set up:
	   you can't connect a "to-the-host" connector to a peripheral.

	   Linux can run in the host, or in the peripheral.  In both cases
	   you need a low level bus controller driver, and some software
	   talking to it.  Peripheral controllers are often discrete silicon,
	   or are integrated with the CPU in a microcontroller.  The more
	   familiar host side controllers have names like "EHCI", "OHCI",
	   or "UHCI", and are usually integrated into southbridges on PC
	   motherboards.

	   Enable this configuration option if you want to run Linux inside
	   a USB peripheral device.  Configure one hardware driver for your
	   peripheral/device side bus controller, and a "gadget driver" for
	   your peripheral protocol.  (If you use modular gadget drivers,
	   you may configure more than one.)

	   If in doubt, say "N" and don't enable these drivers; most people
	   don't have this kind of hardware (except maybe inside Linux PDAs).

	   For more information, see <http://www.linux-usb.org/gadget> and
	   the kernel DocBook documentation for this API.

if USB_GADGET

config USB_GADGET_DEBUG
	boolean "Debugging messages (DEVELOPMENT)"
	depends on DEBUG_KERNEL
	help
	   Many controller and gadget drivers will print some debugging
	   messages if you use this option to ask for those messages.

	   Avoid enabling these messages, even if you're actively
	   debugging such a driver.  Many drivers will emit so many
	   messages that the driver timings are affected, which will
	   either create new failure modes or remove the one you're
	   trying to track down.  Never enable these messages for a
	   production build.

config USB_GADGET_DEBUG_FILES
	boolean "Debugging information files (DEVELOPMENT)"
	depends on PROC_FS
	help
	   Some of the drivers in the "gadget" framework can expose
	   debugging information in files such as /proc/driver/udc
	   (for a peripheral controller).  The information in these
	   files may help when you're troubleshooting or bringing up a
	   driver on a new board.   Enable these files by choosing "Y"
	   here.  If in doubt, or to conserve kernel memory, say "N".

config USB_GADGET_DEBUG_FS
	boolean "Debugging information files in debugfs (DEVELOPMENT)"
	depends on DEBUG_FS
	help
	   Some of the drivers in the "gadget" framework can expose
	   debugging information in files under /sys/kernel/debug/.
	   The information in these files may help when you're
	   troubleshooting or bringing up a driver on a new board.
	   Enable these files by choosing "Y" here.  If in doubt, or
	   to conserve kernel memory, say "N".

config USB_GADGET_VBUS_DRAW
	int "Maximum VBUS Power usage (2-500 mA)"
	range 2 500
	default 2
	help
	   Some devices need to draw power from USB when they are
	   configured, perhaps to operate circuitry or to recharge
	   batteries.  This is in addition to any local power supply,
	   such as an AC adapter or batteries.

	   Enter the maximum power your device draws through USB, in
	   milliAmperes.  The permitted range of values is 2 - 500 mA;
	   0 mA would be legal, but can make some hosts misbehave.

	   This value will be used except for system-specific gadget
	   drivers that have more specific information.

config	USB_GADGET_SELECTED
	boolean

#
# USB Peripheral Controller Support
#
# The order here is alphabetical, except that integrated controllers go
# before discrete ones so they will be the initial/default value:
#   - integrated/SOC controllers first
#   - licensed IP used in both SOC and discrete versions
#   - discrete ones (including all PCI-only controllers)
#   - debug/dummy gadget+hcd is last.
#
choice
	prompt "USB Peripheral Controller"
	depends on USB_GADGET
	help
	   A USB device uses a controller to talk to its host.
	   Systems should have only one such upstream link.
	   Many controller drivers are platform-specific; these
	   often need board-specific hooks.

#
# Emulated controllers
#

config USB_GADGET_MSM_72K
	boolean "MSM 72K Device Controller"
	depends on ARCH_MSM
	select USB_GADGET_SELECTED
	select USB_GADGET_DUALSPEED
	help
	   USB gadget driver for Qualcomm MSM 72K architecture.

	   Say "y" to link the driver statically, or "m" to build a
	   dynamically linked module called "msm72k" and force all
	   gadget drivers to also be dynamically linked.

config USB_MSM_72K
	tristate
	depends on USB_GADGET_MSM_72K
	default USB_GADGET
	select USB_GADGET_SELECTED

endchoice # USB Peripheral Controller

config USB_GADGET_DUALSPEED
	bool
	depends on USB_GADGET
	default n
	help
	  Means that gadget drivers should include extra descriptors
	  and code to handle dual-speed controllers.

#
# USB Gadget Drivers
#
choice
	tristate "USB Gadget Drivers"
	depends on USB_GADGET && USB_GADGET_SELECTED
	default USB_ANDROID
	help
	  A Linux "Gadget Driver" talks to the USB Peripheral Controller
	  driver through the abstract "gadget" API.  Some other operating
	  systems call these "client" drivers, of which "class drivers"
	  are a subset (implementing a USB device class specification).
	  A gadget driver implements one or more USB functions using
	  the peripheral hardware.

	  Gadget drivers are hardware-neutral, or "platform independent",
	  except that they sometimes must understand quirks or limitations
	  of the particular controllers they work with.  For example, when
	  a controller doesn't support alternate configurations or provide
	  enough of the right types of endpoints, the gadget driver might
	  not be able work with that controller, or might need to implement
	  a less common variant of a device class protocol.

# this first set of drivers all depend on bulk-capable hardware.

config USB_ANDROID
	boolean "Android Gadget"
	depends on SWITCH
	help
	  The Android gadget driver supports multiple USB functions.
	  The functions can be configured via a board file and may be
	  enabled and disabled dynamically.

config USB_ANDROID_ACM
	boolean "Android gadget ACM serial function"
	depends on USB_ANDROID
	help
	  Provides ACM serial function for android gadget driver.

config USB_ANDROID_ADB
	boolean "Android gadget adb function"
	depends on USB_ANDROID
	help
	  Provides adb function for android gadget driver.

config USB_ANDROID_DIAG
	boolean "USB MSM7K Diag Function"
	depends on USB_ANDROID
	help
	  Qualcomm diagnostics interface support.

config USB_ANDROID_MASS_STORAGE
	boolean "Android gadget mass storage function"
	depends on USB_ANDROID && SWITCH
	help
	  Provides USB mass storage function for android gadget driver.

config USB_ANDROID_MTP
	boolean "Android MTP function"
	depends on USB_ANDROID
	help
	  Provides Media Transfer Protocol (MTP) support for android gadget driver.

config USB_ANDROID_RNDIS
	boolean "Android gadget RNDIS ethernet function"
	depends on USB_ANDROID
	help
	  Provides RNDIS ethernet function for android gadget driver.

config USB_ANDROID_RNDIS_WCEIS
        boolean "Use Windows Internet Sharing Class/SubClass/Protocol"
        depends on USB_ANDROID_RNDIS
        help
         Causes the driver to look like a Windows-compatible Internet
         Sharing device, so Windows auto-detects it.

         If you enable this option, the device is no longer CDC ethernet
         compatible.

config USB_ANDROID_ACCESSORY
	boolean "Android USB accessory function"
	depends on USB_ANDROID
	help
	  Provides Android USB Accessory support for android gadget driver.

config USB_CSW_HACK
	boolean "USB Mass storage csw hack Feature"
	depends on USB_ANDROID
	help
	 This csw hack feature is for increasing the performance of the mass
	 storage

endchoice # USB Gadget Drivers

if MICROP_COMMON

config USB_ACCESSORY_DETECT
        boolean "USB ACCESSORY DETECT"
        depends on USB_ANDROID
        default n

config USB_ACCESSORY_DETECT_BY_ADC
        boolean "DETECT USB ACCESSORY BY PMIC ADC"
        depends on USB_ANDROID && USB_ACCESSORY_DETECT
        default n

config DOCK_ACCESSORY_DETECT
        boolean "DOCK ACCESSORY DETECT"
        depends on USB_ANDROID
        default n

config USB_BYPASS_VBUS_NOTIFY
        boolean "USB BYPASS VBUS NOTIFY"
        depends on USB_ANDROID
        default n

endif # CONFIG_MICROP_COMMON

endif # USB_GADGET

